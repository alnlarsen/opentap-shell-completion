#compdef tap

_trace() {
  echo "$@" >> ~/tapcomp.log
}

_portable_get_real_dirname() {
  if [[ $(uname) == Darwin ]]; then
    # Mac uses BSD readlink which supports different flags

    # relativePath is empty if this is a regular file
    # Otherwise it is a relative path from the link to the real file
    foundPath="$1"
    relativePath="$(readlink "$foundPath")"
    # Keep looping until the file is resolved to a regular file
    while [[ "$relativePath" ]]; do
      # File is a link; follow it
      pushd "$(dirname "$foundPath")" >/dev/null
      pushd "$(dirname "$relativePath")" >/dev/null
      foundPath="$(pwd)/$(basename "$0")"
      popd >/dev/null
      popd >/dev/null
      relativePath="$(readlink "$foundPath")"
    done

    echo "$(dirname "$foundPath")"
  else
    # We are on linux -- Use GNU Readline normally
    echo "$(dirname "$(readlink -f "$(which "$1")")")"
  fi
}

# return values:
# 0: don't care (let caller decide)
# 1: complete all files 
# 2: complete directories only 
# 3: complete no files or directories
_tap_hardcoded_completions () {
  local dontcare=0
  local complete_all=1 
  local complete_dirs=2 
  local complete_none=3
  local tapdir="$1"

  shift
  local words=($@)

  _package_comp () {
    graphql () {
      local IFS=$'\n'
      local repo="$1"
      # Base64 encode the string so it becomes a valid file path
      local hashed=$(echo "$repo" | base64)

      local cacheBase="/tmp/_tap_completion_cache"
      if [ ! -d "$cacheBase" ]; then
        mkdir -p "$cacheBase"
      fi

      local cacheFile="$cacheBase/$hashed"

      restore_cache () {
        _trace "restoring cache"
        local query='
        query Query { packages(distinctName: true, version: "Any") {
        name
        description }}'
        curl -X POST "$repo/3.1/Query" -H "Accept: application/json" -H "Content-Type: application/x-www-form-urlencoded" -d "$query" 2> /dev/null > "$cacheFile"
      }

      if [ ! -f "$cacheFile" ]; then
        _trace "cache missing"
        restore_cache
      else 
        # refresh the cache if it is more than fifteen minutes old
        local now=$( date +%s )
        local mod_time=$(date -r "$cacheFile" +%s)
        local diff=$(( now - mod_time ))
        if (( diff > ( 60 * 15 ) )); then
          _trace "cache outdated"
          restore_cache
        fi
      fi

      yq '.packages[] | ( (.name | sub(":", "\:")) + ":" + ( .description | sub("\n", " ")))' "$cacheFile"
    }


  local words=($@)
  local w1=$words[1]

  local descriptionQuery='( ( .Package.Description.+content // .Package.Description ) | sub("\n", " ") )'

  case "$w1" in
    install|download|show|list)
      graphql "https://packages.opentap.io"
      return $complete_all
      ;;
    uninstall|verify|test)
      # Parse the package names and descriptions of every package in the '$TAPDIR/Packages/**/package.xml directory'
      local packages=( $(yq -p=xml  ".Package.+Name + \":\" + $descriptionQuery" $tapdir/Packages/**/package.xml ))
      # yq uses '---' as a separator between output from different files
      for package in ${packages[@]/---}
      do
        if [ ! $package = --- ]; then
          echo $package
        fi
      done

      return $complete_none
      ;;
  esac

  return 0
}

_run_comp() {
  local words=($@)
  local w1=$words[1]

  local testplans=( $CURRENT_WORD*.TapPlan )
  if [ ${#testplans[@]} = 0 ]; then
    return $complete_dirs
  fi

  local descriptions=($(yq -p xml 'filename + ":" + ( .TestPlan.OpenTap*Description // "" | (("Base64=" + .Base64) // .) | sub("\n", " ") ) ' ${testplans[@]}))

    # yq uses '---' as a separator between output from different files
    for description in ${descriptions[@]/---}
    do
      local filename=${description%%:*}
      local d=${description#*:}
      # If the description is a Base64 encoding, decode it
      if [[ "$d" == "Base64="* ]]; then
        d="$(echo "${d##Base64=}" | base64 -d)"
        # and replace any newlines with spaces
        d="${d//$'\n'/ }"
      fi
      if [ ! "$d" = "" ]; then
        echo "$filename:$d"
      else
        echo "$filename"
      fi
    done

    return $complete_dirs
  }

  local w1=$words[1]

  case "$w1" in
    package)
      _package_comp "${words[@]:1:${#words[@]}}"
      return $?
      ;;
    run)
      _run_comp "${words[@]:1:${#words[@]}}"
      return $?
  esac
}

_tap_complete_fn () {
  local IFS=$'\n'
  if [ ! -x "$1" ]; then
    # fail fast when $1 is not an executable
    return;
  fi

  local binary="$1"
  local tapdir="`_portable_get_real_dirname "$binary"`"
  local yqPath="$tapdir/Packages/ShellCompletion/yq"
  local cachePath="$tapdir/.tap-completions.json"

  shift 
  local args=($@)

  yq()
  {
    "${yqPath}" -M "$@"
  }

  if [ ! -x "$yqPath" ]; then 
    # We cannot do anything if jq is not installed. We cannot even give an error.
    # This is probably happening because the plugin is not installed.
    return;
  fi

  if [ ! -f "$cachePath" ]; then
    # if the cache does not exist it should be created
    "${binary}" completion regenerate > /dev/null
  fi

  local query="."
  for word in ${args[@]};
  do
    if [[ "$word" == -* ]]; then
      break;
    fi
    # Here we save the most immediate parent in $fallback in cases where e.g. an unnamed argument was specified
    # Without the fallback we would not be able to continue suggesting flags after e.g. 
    # tap package install CSV --!! or
    # tap run ./a.TapPlan --!!
    # This also means that currently we will keep suggesting invalid commands after 'tap tap tap tap -> package'
    # We could do more to validate the arguments here.
    query="$query | ( . as \$fallback | .Completions[] | select(.Name == \"$word\") | . // \$fallback )"
  done

  # the previous word on the line
  local previousWord="${args[$CURRENT-1]}"

  if [[ "$previousWord" == -* ]]; then
    local flagQuery="$query | .FlagCompletions[] | select (\"-\" + .ShortName == \"$previousWord\" or \"--\" + .LongName == \"$previousWord\") | [.Type, .SuggestedCompletions[]][]"
    local flagopts=($(yq "$flagQuery" "$cachePath"))

    # If the current flag is a bool, just continue since it requires no argument
    # otherwise we should only suggest completions for this flag and return
    if [ ! "$flagopts" = "System.Boolean" ]; then
      printf "%s\n" "${flagopts[@]:1}"
      if [[ "$flagopts" == *"System.String"* ]]; then
        return 1;
      fi
      return 0;
    fi
  fi

  _tap_hardcoded_completions "$tapdir" "${args[@]}"
  local filesHandled=$?

  local joinedDescription="( .Description // .Type |= sub(\"\n\", \" \") | \":\" + .Description // .Type )"
  local shortnameQuery="   ( .FlagCompletions[] | select(.ShortName != null ) | \"-\" + .ShortName + $joinedDescription ) "
  local longnameQuery="    ( .FlagCompletions[] | select(.LongName  != null ) | \"--\" + .LongName + $joinedDescription ) "
  local completionsQuery=" ( .Completions[] | .Name + $joinedDescription  ) "
  query="$query | ( .UnnamedCompletion.Type, $shortnameQuery , $longnameQuery , $completionsQuery ) "

  local candidates=($(yq "$query" "$cachePath"))
  printf "%s\n" "${candidates[@]:1:${#candidates[@]}}"

  if [ ! $filesHandled = 0 ]; then
    return $filesHandled
  fi

  if [[ "$candidates" == *"System.String"* ]]; then
    return 1;
  fi

  return 0;
}

_tap_subcommands(){
  local binary="$words[1]"
  local line
  _arguments "*::args:->args"

  local CURRENT_WORD="${line[CURRENT]}"
  local relevant=(${${line[@]:0:$((CURRENT - 1))}})

  declare -a array_of_lines
  # _tap_complete_fn sets exit code to 1 if files should be suggested
  array_of_lines=($(_tap_complete_fn "$binary" ${relevant[@]}))
  local suggestFiles=$?

  if [ $suggestFiles = 1 ]; then
    _files
  fi

  if [ $suggestFiles = 2 ]; then
    _files -/ 
  fi

  # Avoid suggesting anything if the string is just whitespace
  if [[ "${array_of_lines[@]}" = *[![:space:]]* ]]; then
    _describe 'command' array_of_lines 
  fi

}

_tap(){
  words[1]="$(which "$words[1]" 2> /dev/null)"
  if [ ! -x "$words[1]" ]; then
    return
  fi

  local IFS=$'\n'
  _tap_subcommands
}

